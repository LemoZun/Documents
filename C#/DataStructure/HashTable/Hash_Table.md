# 해시 테이블(Hash Table)

키 값을 해시함수로 해싱해 특정 위치로 직접 액세스하도록 만든 방식

해시 : 임의의 길이를 가진 데이터를 `해시 알고리즘`을 사용해 고정된 길이를 가진 데이터로 출력한 값

## 해시 테이블 구현

    <해시테이블 구현>
    데이터를 담을 테이블을 이미 크게 확보해 놓은 후, 입력받은 키를 해싱하여 테이블 고유한 index를 계산하고 데이터를 담아 보관

           
                     해싱
                    ┌────┐
                2 ─→│    │─→   2
              998 ─→│해시│─→ 998
             2066 ─→│함수│─→  66
             8027 ─→│    │─→  27
                    └────┘
          
             [0]   [1]   [2]        [27]        [66]       [997] [998] [999]
           ┌─────┬─────┬─────┬─  ─┬──────┬─  ─┬──────┬─  ─┬─────┬─────┬─────┐
           │     │     │  2  │....│ 8027 │....│ 2066 │....│     │ 998 │     │
           └─────┴─────┴─────┴─  ─┴──────┴─  ─┴──────┴─  ─┴─────┴─────┴─────┘



### 특성 
- 단방향성
- 해시 충돌 최소화
- 고정된 데이터 길이

### 자주 사용하는 용어
- 키(key) : 데이터를 저장하고 찾기 위해 사용되는 고유한 식별자 , 자료를 찾기 위한 지정값
- 값(value) : 키를 기준으로 한 위치에 저장되는 데이터
- `해시함수` : 입력된 키를 해시 테이블의 주소(해시코드)로 변환하는 함수(고유한 index를 만드는 함수) 
  - 조건으로 하나의 키값을 해싱하는 경우 반드시 `항상 같은 index`를 반환해야 함
  - 대표적인 해시 함수로 나눗셈법이 있음
    - ex) 2581 → (2581 % 1000) = 581
    - ex) "임의의 문자열" → 문자열을 이진수로 변환 % 1000 = 해싱된 값

<br>

## 해시함수의 충돌
   
해시함수가 서로 다른 입력 값에 대해 동일한 해시테이블 주소를 반환하는 것 <br>
모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음



          
                     해싱
                    ┌────┐
             1081 ─→│해시│─→  81
             2081 ─→│함수│─→  81
                    └────┘
          
             [0]   [1]   [2]          [81]          [997] [998] [999]
           ┌─────┬─────┬─────┬─  ─┬───────────┬─  ─┬─────┬─────┬─────┐
           │     │     │     │....│ 1081 2081 │....│     │     │     │
           └─────┴─────┴─────┴─  ─┴───────────┴─  ─┴─────┴─────┴─────┘
                                    ↑충돌발생

### 충돌해결방안 - 체이닝

해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식

장점 : 해시테이블에 자료사용률에 따른 성능저하가 적음  
단점 : 해시테이블 외 추가적인 저장공간이 필요, 삽입삭제시 오버헤드가 발생
          
             [0]   [1]   [2]        [81]      [997] [998] [999]
           ┌─────┬─────┬─────┬─  ─┬──────┬─  ─┬─────┬─────┬─────┐
           │     │     │     │....│  │   │....│     │     │     │
           └─────┴─────┴─────┴─  ─┴──│───┴─  ─┴─────┴─────┴─────┘
                                     ↓
                                  ┌──────┬─┐ ┌──────┬─┐
                                  │ 1081 │──→│ 2081 │ │
                                  └──────┴─┘ └──────┴─┘

### 충돌해결방안 - 개방주소법

해시 충돌이 발생하면 다른 빈 공간에 데이터를 삽입하는 방식
해시 충돌시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정

장점 : 추가적인 저장공간이 필요하지 않음, 삽입삭제시 오버헤드가 적음   
단점 : 해시테이블에 자료사용률에 따른 성능저하가 발생
                                    
             [0]   [1]   [2]        [81]   [82]       [997] [998] [999]
           ┌─────┬─────┬─────┬─  ─┬──────┬──────┬─  ─┬─────┬─────┬─────┐
           │     │     │     │....│ 1081 │      │....│     │     │     │
           └─────┴─────┴─────┴─  ─┴──────┴──────┴─  ─┴─────┴─────┴─────┘
                                    ↑2081(충돌)
          
             [0]   [1]   [2]        [81]   [82]       [997] [998] [999]
           ┌─────┬─────┬─────┬─  ─┬──────┬──────┬─  ─┬─────┬─────┬─────┐
           │     │     │     │....│ 1081 │ 2081 │....│     │     │     │
           └─────┴─────┴─────┴─  ─┴──────┴──────┴─  ─┴─────┴─────┴─────┘
                                           ↑(다음위치에 저장)

### 충돌 해결방안 정리

- 체이닝(Chaining) : 배열의 원소를 연결리스트로 구현해 같은 키값을  가지는 데이터를 보관함
- 개방주소법의 선형탐사 : 배열을 지정된 폭만큼 순회한 후 빈 공간에 보관한다.   
- 개방주소법의 제곱탐사 : n^2만큼 떨어진 주소를 계속 탐색해서 빈 공간에 보관한다.
- 개방주소법의 이중해싱 : 충돌된 해시값을 중복되지 않을때까지 해시함

## 해시테이블 효율

해시테이블의 공간 사용률이 높을 경우(통계적으로 70% 이상) 급격한 성능저하가 발생한다.  
이런 경우 재해싱을 통해 공간 사용률을 낮추어(공간을 새로 할당해) 다시 효율을 확보함

재해싱 : 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱하여 보관
          
           ┌─────┬─────┬─────┬─────┬─────┐
           │ 124 │ 258 │     │ 857 │ 858 │
           └─────┴─────┴─────┴─────┴─────┘
             ↓ 재해싱
           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
           │ 124 │     │     │ 857 │ 858 │     │     │ 258 │     │     │
           └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘


### 해시테이블 시간복잡도
    접근       탐색       삽입       삭제
    X          O(1)      O(1)       O(1)

- 접근을 원하는게 아닌 키값으로 찾아서 쓰는 용도

- 공간 사용률이 높아질수록(삽입 삭제가 빈번하게 일어나면) 삽입 삭제가 느려질 수 있음.
  - 연결리스트와 비슷해 보이지만 해시테이블은 탐색을 빠르게 하는 용도.
  - 삭제 과정에서 값을 삭제할때 빈공간으로 만드는 것이 아닌 삭제했다는 표시를 해서 자리를 계속 차지하므로 삭제 또한 빈번하게 이뤄져선 안됨.

<br>

## 딕셔너리(Dictionary)

해시테이블의 c# 언어 구현체   
탐색이 자주 일어날 때 쓰면 좋음


```C#
static void Main()
{
    // 해시테이블 기반의 dictionary 자료구조
    Dictionary<string, Monster> monsterDic = new Dictionary<string, Monster>();

    // 삽입
    // Add(키값 , 실제 value)
    monsterDic.Add("피카츄", new Monster("피카츄", MonsterType.Electric, 80));
    monsterDic.Add("파이리", new Monster("파이리", MonsterType.Fire, 90));
    monsterDic.Add("꼬부기", new Monster("꼬부기", MonsterType.Water, 70));
    monsterDic.Add("이상해씨", new Monster("이상해씨", MonsterType.Electric, 100));
    monsterDic["피죤"] = new Monster("피죤", MonsterType.Wind, 50); // 이렇게도 가능, 없으면 추가, 있었으면 대입
    
    // try도 사용 가능
    // monsterDic.TryAdd
    // monsterDic.TryGetValue
    

    // 삭제
    // Remove(키값)
    monsterDic.Remove("이상해씨");

    // 탐색
    // 딕셔너리[키값]
    Monster find1 = monsterDic["피카츄"]; // O(1)
    Console.WriteLine($"{find1.name},{find1.type},{find1.hp}");

    if(monsterDic.ContainsKey("이상해씨")) // 있는지 없는지 확인하는 메서드
    {
        Monster find2 = monsterDic["이상해씨"];
    }
    monsterDic["피카츄"].hp = 110; // 키값(인덱서)를 통해 값 변경 가능 
}

public enum MonsterType { Fire, Water, Grass, Electric, Wind }
public class Monster
{
    public string name;
    public MonsterType type;
    public int hp;

    public Monster(string name, MonsterType type, int hp)
    {
        this.name = name;
        this.type = type;
        this.hp = hp;
    }
}
```
