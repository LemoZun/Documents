# 순차 리스트
런타임 중 크기를 확장 할 수 있는 배열 기반의 자료구조  
배열요소의 갯수를 특정 할 수 없는 경우 사용하기 좋다.

## 제네릭 컬렉션 - List\<T>
배열과는 다르게 데이터를 추가 할 때마다 동적 할당 가능  
크기가 확정되었다면 배열, 크기가 정해지지 않았다면 list를 쓸 수 있다.
``` c#
using System.Collections.Generic; // 일반화 된 자료구조를 사용할 때 적어줌
static void Main(string[] args)
{
    List<string> list = new List<string>();
    //삽입
    list.Add("0번 데이터");
    list.Add("1번 데이터");
    list.Add("2번 데이터"); // 맨 뒤에 바로 붙여넣어서 속도가 빠름 O(1)
    list.Add("3번 데이터");
    list.Add("4번 데이터");
    ///크기를 동적 할당 가능
    list.Insert(2, "Insert로 추가"); //n번째 자리에 추가하고 나머지 자료들을 뒤로 미룸 O(n)

    //삭제
    list.Remove("1번 데이터"); // O(n) 지우고 데이터 인덱스를 당겨옴
    list.Remove("없는 데이터"); // 없는 데이터를 지우려고 하면 false를 반환함 
    list.RemoveAt(1); // 인덱스를 지정해서 지우기도 가능 O(n)

    list[0] = "바꾼 0번 데이터"; // 인덱스로 접근 가능, 인덱스를 써서 바로 접근 할 수 있기 때문에 O(n)

    //탐색
    int index = list.IndexOf("3번 데이터"); // O(n) 인덱스 추출 가능
    bool contain = list.Contains("3번 데이터"); // O(n) 포함하고 있는지 아닌지 확인 가능

}
```
### 리스트의 시간 복잡도 정리
        <리스트 시간복잡도>
         접근    탐색    삽입    삭제
         O(1)    O(n)   O(n)    O(n)


## 리스트의 구현
리스트는 배열기반의 자료구조이며, 배열은 크기를 변경할 수 없는 자료구조<br>
리스트는 동작 중 크기를 확장하기 위해 `포함한 데이터보다 더욱 큰 배열`을 사용


           
          
           크기 = 3, 용량 = 8       크기 = 4, 용량 = 8       크기 = 5, 용량 = 8
           ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
           │1│2│3│ │ │ │ │ │        │1│2│3│4│ │ │ │ │        │1│2│3│4│5│ │ │ │
           └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


           <리스트 삽입>
           중간에 데이터를 추가하기 위해 이후 데이터들을 뒤로 밀어내고 삽입 진행
                ↓                        ↓                        ↓
           ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
           │1│2│3│4│ │ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│A│3│4│ │ │ │
           └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


           <리스트 삭제>
           중간에 데이터를 삭제한 뒤 빈자리를 채우기 위해 이후 데이터들을 앞으로 당김
                ↓                        ↓
           ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
           │1│2│A│3│4│ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│3│4│ │ │ │ │
           └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


           <리스트 용량>
           용량을 가득 채운 상황에서 데이터를 추가하는 경우
           더 큰 용량의 배열을 새로 생성한 뒤 데이터를 복사하여 새로운 배열을 사용
          
           1. 리스트가 가득찬 상황에서 새로운 데이터 추가 시도
           크기 = 8, 용량 = 8
           ┌─┬─┬─┬─┬─┬─┬─┬─┐
           │1│2│3│4│5│6│7│8│ ← A 추가
           └─┴─┴─┴─┴─┴─┴─┴─┘
          
           2. 새로운 더 큰 배열 생성
           크기 = 8, 용량 = 8          크기 = 0, 용량 = 16
           ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
           │1│2│3│4│5│6│7│8│ ← A 추가  │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │
           └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
          
           3. 새로운 배열에 기존의 데이터 복사
           크기 = 8, 용량 = 8          크기 = 8, 용량 = 16
           ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
           │1│2│3│4│5│6│7│8│ ← A 추가  │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │
           └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
          
           4. 기본 배열 대신 새로운 배열을 사용
           크기 = 8, 용량 = 16
           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
           │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │ ← A 추가
           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
          
           5. 빈공간에 데이터 추가
           크기 = 9, 용량 = 16
           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
           │1│2│3│4│5│6│7│8│A│ │ │ │ │ │ │ │
           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

``` c#
static void Main(string[] args)
{
    List<int> list = new List<int>();

    for (int i = 0; i < 20; i++)
    {
        list.Add(i);
        Console.WriteLine($"리스트의 count = {list.Count}, 리스트의 capacity = {list.Capacity}");
    }
   
}
    
```
 Capacity에 Count가 도달 할 때마다 Capacity를 두배로 늘리고 기존데이터를 복사해 새로운 list에 넣고 기존 데이터를 버린다<br>
즉, 가비지가 생성되며 복사와 삭제 연산이 추가로 일어나게 된다.
```c#
    List<int> list = new List<int>(40); 
    // capacity를 지정해서 만들어주면 위의 상황을 방지 할 수 있다.
    //StringBuilder도 유사한 방식으로 구현되어 있다.
```
